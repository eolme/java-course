# Спецкурс по языку Java
## Лабораторная работа №5
### Задание на лабораторную работу

В процессе написания тестовых заданий ознакомиться с общими принципами создания многопоточных приложений.

#### Задание 1
Создать два класса нитей, наследующих от класса `Thread`, взаимодействующих друг с другом с помощью одного промежуточного объекта типа интерфейс из вашей иерархии (см л.р. №3).

Первая нить последовательно заполняет поле-массив промежуточного объекта (изначально он заполнен нулями) произвольными различными величинами (например, случайными), отличными от нуля. Каждый раз, когда она помещает значение в массив, она выводит на экран сообщение вида `Write: ### to position ###`. По достижении конца массива нить заканчивает свое выполнение.

Вторая нить последовательно считывает значения из массива и выводит их на экран сообщениями вида `Read: ### from position ###`. По достижении конца массива нить заканчивает свое выполнение.

В методе `main()` следует создать 3 участвующих в процессе объекта (две нити и объект интерфейса для записи/чтения в него) и запустить нити на выполнение. Запустите программу несколько раз. Попробуйте варьировать приоритеты нитей.

#### Задание 2
Создайте два новых класса нитей (реализуют интерфейс `Runnable`), обеспечивающих последовательность операций чтения-записи (т.е. на экран сообщения выводятся в порядке write-read-write-read-…) независимо от приоритетов потоков. Для этого потребуется описать некий вспомогательный класс `<Интерфейс>Synchronizer`, объект которого и будет использоваться при взаимодействии нитей.

Пример класса объекта-посредника (данный пример предлагает один из вариантов, причем не самый лучший, он легко может быть изменен и оптимизирован):

```java
public class <Интерфейс>Synchronizer {
  private  i;
  private volatile int current = 0;
  private Object lock = new Object();
  private boolean set = false;
   
  public <Интерфейс>Synchronizer(<Интерфейс> i) {
    this.i = i;
  }
   
  public double read() throws InterruptedException {
    double val;
    synchronized(lock) {
      if (!canRead()) throw new InterruptedException();
      while (!set)
        lock.wait();
      val = i.getElement(current++);
      System.out.println("Read: " + val);
      set = false;
      lock.notifyAll();
    }
    return val;
  }  
   
  public void write(double val) throws InterruptedException {
    synchronized(lock) {
      if (!canWrite()) throw new InterruptedException();
      while (set)
        lock.wait();
      i.setElement(current, val);
      System.out.println("Write: " + val);
      set = true;
      lock.notifyAll();
    }
  }
  
  public boolean canRead() {
    return current < i.getSize();
  }
  
  public boolean canWrite() {
    return (!set && current < i.getSize()) || (set && current < i.getSize() - 1);
  }
}
```

#### Задание 3
Добавить в класс со статическими методами обработки объектов (созданный в л. р. 4) реализацию метода `<Интерфейс> synchronized<Интерфейс> (<Интерфейс> i)`, возвращающего ссылку на оболочку указанного интерфейса, безопасную с точки зрения многопоточности. Для этого потребуется описать новый класс, реализующий ваш интерфейс `<Интерфейс>` и представляющий собой оболочку, синхронизирующую все методы интерфейса (состоящую из синхронизированных методов вашего интерфейса).

#### Контрольные вопросы
1. Многопоточный подход, особенности
2. Класс Thread для запуска потоков
3. Интерфейс Runnable для запуска потоков
4. Класс Thread для управления потоками
5. Понятие группы потоков
6. Управление группой потоков
7. Потоки-демоны
8. Проблемы совместного использования ресурсов
9. Синхронизированный блок
10. Синхронизированный метод
11. Поля volatile
12. Методы класса Object для синхронизации потоков
13. Правила прерывания потоков, запрещенные метод

[← Вернуться на главную](https://eolme.github.io/java-course/)
